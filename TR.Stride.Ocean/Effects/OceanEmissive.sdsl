namespace TR.Stride.Ocean
{
    shader OceanEmissive 
        : ComputeColor, OceanShadingCommon, MaterialPixelStream, NormalStream, PositionStream4, Transformation, DepthBase, ShaderBase, Global, OpaqueBase
    {
        override float4 Compute()
        {
            // Sample depth buffer
		    float2 screenPos = streams.ShadingPosition.xy;
		    float2 screenSpaceUv = float2(screenPos.x / ViewSize.x, screenPos.y / ViewSize.y);

            // Sample scene depth
            streams.sceneDepthVS = ComputeDepthFromUV(screenSpaceUv);

            // Compute view space depth
		    float depthPS = streams.ShadingPosition.z;
            streams.depthVS = ComputeDepthFromZProj(depthPS);

            if (streams.sceneDepthVS <= streams.depthVS)
                discard;

            float4 derivatives = Derivatives_c0.Sample(AnisotropicRepeatSampler, streams.worldUV / LengthScale0);
            if (Lod == 0 || Lod == 1)
            {
                derivatives += Derivatives_c1.Sample(AnisotropicRepeatSampler, streams.worldUV / LengthScale1) * streams.lodScales.y;
            }
            if (Lod == 0)
            {
                derivatives += Derivatives_c2.Sample(AnisotropicRepeatSampler, streams.worldUV / LengthScale2) * streams.lodScales.z;
            }

            float2 slope = float2(derivatives.x / (1 + derivatives.z), derivatives.y / (1 + derivatives.w));
            float3 worldNormal = normalize(float3(-slope.x, 1, -slope.y));
            streams.meshNormalWS = streams.normalWS = worldNormal;

            streams.jacobian = 0;
            if (Lod == 0)
            {
                streams.jacobian = 
                    Turbulence_c0.Sample(AnisotropicRepeatSampler, streams.worldUV / LengthScale0).x
                    + Turbulence_c1.Sample(AnisotropicRepeatSampler, streams.worldUV / LengthScale1).x
                    + Turbulence_c2.Sample(AnisotropicRepeatSampler, streams.worldUV / LengthScale2).x;
                streams.jacobian = min(1, max(0, (-streams.jacobian + FoamBiasLOD2) * FoamScale));
            }
            else if (Lod == 1)
            {
                streams.jacobian = 
                    Turbulence_c0.Sample(AnisotropicRepeatSampler, streams.worldUV / LengthScale0).x
                    + Turbulence_c1.Sample(AnisotropicRepeatSampler, streams.worldUV / LengthScale1).x;
                streams.jacobian = min(1, max(0, (-streams.jacobian + FoamBiasLOD1) * FoamScale));
            }
            else
            {
                streams.jacobian = Turbulence_c0.Sample(AnisotropicRepeatSampler, streams.worldUV / LengthScale0).x;
                streams.jacobian = min(1, max(0, (-streams.jacobian + FoamBiasLOD0) * FoamScale));
            }

            float depthDifference = max(0, streams.sceneDepthVS - streams.depthVS - 1);
            float foam = FoamTexture.Sample(AnisotropicRepeatSampler, streams.worldUV).x;
            streams.jacobian += max(0, ContactFoam * saturate(max(0, foam - depthDifference) * 5) * 0.9);

            streams.matDiffuse = lerp(0, FoamColor, streams.jacobian);
            streams.matDiffuse.a = 1;

            float3 viewVector = Eye.xyz - streams.PositionWS.xyz;
            float distanceGloss = lerp(1 - Roughness, MaxGloss, 1 / (1 + length(viewVector) * RoughnessScale));
            streams.matGlossiness = lerp(distanceGloss, 0, streams.jacobian);

            return float4(1, 1, 1, 1);
        }
    };
}